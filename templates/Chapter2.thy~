theory Chapter2
imports Main
begin

text\<open>
\section*{Chapter 2}

\exercise
Use the \textbf{value} command to evaluate the following expressions:
\<close>

value "1 + (2::nat)"
value "1 + (2::int)"
value  "1 - (2::nat)"
value  "1 - (2::int)"
value "[a,b] @ [c,d]"


text\<open>
\endexercise


\exercise
Recall the definition of our own addition function on @{typ nat}:
\<close>

fun add :: "nat \<Rightarrow> nat \<Rightarrow> nat" where
"add 0 n = n" |
"add (Suc m) n = Suc(add m n)"

text\<open>
Prove that @{const add} is associative and commutative.
You will need additional lemmas.
\<close>

lemma add_assoc [simp]: "add (add m n) p = add m (add n p)"
  apply(induction m)
   apply(auto)
  done

lemma add_0 [simp]: "add n 0 = n"
  apply(induction n)
  apply(auto)
  done

lemma suc_0 [simp]: "Suc (add n m) = add n (Suc m)"
  apply(induction n)
  apply(auto)
  done

lemma add_comm: "add m n = add n m"
  apply(induction m)
  apply(simp)
  apply(auto)
  done

text\<open> Define a recursive function \<close>

fun double :: "nat \<Rightarrow> nat" where
"double 0 = 0" |
"double m = add m m"
text "double m = m + (double (m-1))"

(* your definition/proof here *)

text\<open> and prove that \<close>

lemma double_add: "double m = add m m"
  apply(induction m)
  apply(auto)
  done
(* your definition/proof here *)
text\<open>
\endexercise


\exercise
Define a function that counts the number of occurrences of
an element in a list:
\<close>

fun count :: "'a list \<Rightarrow> 'a \<Rightarrow> nat" where
(* your definition/proof here *)
"count Nil a = 0" |
"count (x # xs) a =  (if x = a then 1 else 0) + (count xs a)" 

text \<open>
Test your definition of @{term count} on some examples.
Prove the following inequality:
\<close>
value "count [a,b,b] b"
value "count Nil a"
value "count [a,b,a,ab,a] b"
value "count [1::nat,2::nat,2::nat] 2::nat"
value "count [1::nat,2::nat,2::nat] 1::nat"


theorem "count xs x \<le> length xs"
  apply(induction xs)
   apply(auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise


\exercise
Define a function @{text snoc} that appends an element to the end of a list.
Do not use the existing append operator @{text "@"} for lists.
\<close>

fun snoc :: "'a list \<Rightarrow> 'a \<Rightarrow> 'a list" where
"snoc Nil x = x # Nil" |
"snoc (x # xs) y = x # (snoc xs y)"
(* your definition/proof here *)

value "snoc [a,b,c] d"
value "snoc [] a"
value "snoc [a] b"

text \<open>
Convince yourself on some test cases that your definition
of @{term snoc} behaves as expected.
With the help of @{text snoc} define a recursive function @{text reverse}
that reverses a list. Do not use the predefined function @{const rev}.
\<close>

fun reverse :: "'a list \<Rightarrow> 'a list" where
"reverse Nil = Nil" |
"reverse (x # xs) = snoc (reverse xs) x"
(* your definition/proof here *)

value "reverse [a,b,c]"
value "reverse [a]"
value "snoc (reverse [a,b,c]) d"
value  "reverse (snoc (reverse [a,b,c]) d)"
value  "reverse ( (reverse (d # [a,b,c])))"
value  "snoc (reverse (reverse [a,b,c]))  d"
value  "reverse ( reverse (snoc [a,b,c] d))"
value  "snoc [a,b,c] d"
value "reverse (d # [a,b,c])"


text \<open>
Prove the following theorem. You will need an additional lemma.
\<close>

lemma test_case : "snoc [] c = [c]"
apply(auto)
done

lemma rev_as_snoc [simp]: "reverse (snoc xs x) = x # (reverse xs)"
  apply(induction xs)
   apply(auto)
  done

theorem "reverse (reverse xs) = xs"
  apply(induction xs)
  apply(auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise


\exercise
The aim of this exercise is to prove the summation formula
\[ \sum_{i=0}^{n}i = \frac{n(n+1)}{2} \]
Define a recursive function @{text "sum_upto n = 0 + ... + n"}:
\<close>

fun sum_upto :: "nat \<Rightarrow> nat" where
"sum_upto 0 = 0" |
"sum_upto n = n + sum_upto (n-1)"
(* your definition/proof here *)

value "sum_upto 3"

text \<open>
Now prove the summation formula by induction on @{text "n"}.
First, write a clear but informal proof by hand following the examples
in the main text. Then prove the same property in Isabelle:
\<close>

lemma "sum_upto n = n * (n+1) div 2"
(* your definition/proof here *)
  apply(induction n)
   apply(auto)
  done

text\<open>
\endexercise


\exercise
Starting from the type @{text "'a tree"} defined in the text, define
a function that collects all values in a tree in a list, in any order,
without removing duplicates.
\<close>
datatype 'a tree = Tip | Node "'a tree" 'a "'a tree"

fun contents :: "'a tree \<Rightarrow> 'a list" where
"contents Tip = Nil"|
"contents (Node l a r) = a # (contents l) @  (contents r)"
(* your definition/proof here *)

text\<open>
Then define a function that sums up all values in a tree of natural numbers
\<close>

fun sum_tree :: "nat tree \<Rightarrow> nat" where
"sum_tree Tip = 0" | 
"sum_tree (Node l a r) = a + (sum_tree l) + (sum_tree r)"
(* your definition/proof here *)

text\<open> and prove \<close>

lemma "sum_tree t = sum_list(contents t)"
  apply (induction t)
   apply (auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise

\exercise
Define a new type @{text "'a tree2"} of binary trees where values are also
stored in the leaves of the tree.  Also reformulate the
@{text mirror} function accordingly. Define two functions \<close>
datatype 'a tree2 = Tip 'a | Node "'a tree2" 'a "'a tree2"

fun pre_order :: "'a tree2 \<Rightarrow> 'a list" where
"pre_order (Tip a) = [a]" |
"pre_order (Node l a r) = [a] @ (pre_order l) @ (pre_order r)"
(* your definition/proof here *)

value "pre_order (Tip a)"
value "pre_order (Node (Tip a) b (Tip c))"
value "pre_order (Node (Node (Tip b) a (Tip c)) r (Tip d))"

fun post_order :: "'a tree2 \<Rightarrow> 'a list" where
"post_order (Tip a) = [a]" |
"post_order (Node l a r) = (post_order l) @ (post_order r) @ [a]"
(* your definition/proof here *)

value "post_order (Tip a)"
value "post_order (Node (Tip a) b (Tip c))"
value "post_order (Node (Node (Tip b) a (Tip c)) r (Tip d))"

text\<open>
that traverse a tree and collect all stored values in the respective order in a list. Prove \<close>

fun mirror ::  "'a tree2 => 'a tree2" where
"mirror (Tip a) =  (Tip a)" |
"mirror (Node l a r) = Node (mirror r) a (mirror l)"

lemma "pre_order (mirror t) = rev (post_order t)"
  apply(induction t)
   apply(auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise

\exercise
Define a recursive function
\<close>

fun intersperse :: "'a \<Rightarrow> 'a list \<Rightarrow> 'a list" where
"intersperse a Nil = Nil" |
"intersperse a (x # Nil) = (x # Nil)" |
"intersperse a (x # xs) = x # a # (intersperse a xs)"
(* your definition/proof here *)

value "intersperse a [b,b,b,b,b]"
value "intersperse a [b,b]"

text\<open>
such that @{text "intersperse a [x\<^sub>1, ..., x\<^sub>n] = [x\<^sub>1, a, x\<^sub>2, a, ..., a, x\<^sub>n]"}.
Prove
\<close>

lemma "map f (intersperse a xs) = intersperse (f a) (map f xs)"
  apply(induction xs rule: intersperse.induct)
  apply(auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise


\exercise
Write a tail-recursive variant of the @{text add} function on @{typ nat}:
\<close>

fun itadd :: "nat \<Rightarrow> nat \<Rightarrow> nat" where
"itadd 0 n = n" |
"itadd (Suc m) n = itadd m (Suc n)"
(* your definition/proof here *)

value "itadd 4 3"

text\<open>
Tail-recursive means that in the recursive case, @{const itadd} needs to call
itself directly: \mbox{@{term"itadd (Suc m) n"}} @{text"= itadd \<dots>"}.
Prove
\<close>

lemma "itadd m n = add m n"
  apply (induction m arbitrary: n)
   apply (auto)
  done
(* your definition/proof here *)

text\<open>
\endexercise


\exercise\label{exe:tree0}
Define a datatype @{text tree0} of binary tree skeletons which do not store
any information, neither in the inner nodes nor in the leaves.
Define a function that counts the number of all nodes (inner nodes and leaves)
in such a tree:
\<close>
datatype tree0 = Leaf | Node tree0 tree0

fun nodes :: "tree0 \<Rightarrow> nat" where
"nodes Leaf = 1 " |
"nodes (Node l r) = 1 + (nodes l) + (nodes r)"
(* your definition/proof here *)

value "nodes Leaf"
value "nodes (Node (Node Leaf Leaf) Leaf)"

text \<open>
Consider the following recursive function:
\<close>

fun explode :: "nat \<Rightarrow> tree0 \<Rightarrow> tree0" where
"explode 0 t = t" |
"explode (Suc n) t = explode n (Node t t)"

text "= add a new parent node and double the current tree"
text "in particular this means that explode 2 creates a new parent node, doubles the tree and then doubles the tree with new parent node"

value "nodes (Node (Node Leaf Leaf) Leaf)"
value "nodes (explode 2 (Node (Node Leaf Leaf) Leaf))"

text \<open>
Experiment how @{text explode} influences the size of a binary tree
and find an equation expressing the size of a tree after exploding it
(\noquotes{@{term [source] "nodes (explode n t)"}}) as a function
of @{term "nodes t"} and @{text n}. Prove your equation.
You may use the usual arithmetic operations including the exponentiation
operator \<open>\<close>@{text"^"}''. For example, \noquotes{@{prop [source] "2 ^ 2 = 4"}}.

Hint: simplifying with the list of theorems @{thm[source] algebra_simps}
takes care of common algebraic properties of the arithmetic operators.
\endexercise
\<close>


lemma exploding : "nodes (explode n t) = (nodes t) * (2^n) + (2^n)-1"
  apply(induction n arbitrary: t)
  apply(simp_all add: algebra_simps)
  done


text\<open>

\exercise
Define arithmetic expressions in one variable over integers (type @{typ int})
as a data type:
\<close>

datatype exp = Var | Const int | Add exp exp | Mult exp exp

text\<open>
Define a function @{text eval} that evaluates an expression at some value:
\<close>

fun eval :: "exp \<Rightarrow> int \<Rightarrow> int" where
"eval Var n = n" |
"eval (Const m) n = m" |
"eval (Add t1 t2) n = (eval t1 n) + (eval t2 n)" |
"eval (Mult t1 t2) n = (eval t1 n) * (eval t2 n)"
(* your definition/proof here *)

value "eval (Add (Mult (Const 2) Var) (Const 3)) i"

text\<open>
For example, @{prop"eval (Add (Mult (Const 2) Var) (Const 3)) i = 2*i+3"}.

A polynomial can be represented as a list of coefficients, starting with
the constant. For example, @{term "[4, 2, -1, 3::int]"} represents the
polynomial $4 + 2x - x^2 + 3x^3$.
Define a function @{text evalp} that evaluates a polynomial at a given value:
\<close>

fun evalp :: "int list \<Rightarrow> int \<Rightarrow> int" where
"evalp [] _ = 0" |
"evalp (c # cs) x = c + x * evalp cs x"
(* your definition/proof here *)

value "evalp [2,3,4] 2"

text\<open>
Define a function @{text coeffs} that transforms an expression into a polynomial.
This will require auxiliary functions.
\<close>

value "evalp [1] (-1)"
text "3 + 1x + 2x^2"
value "eval (Add (Const 3) (Add (Mult (Const 1) Var) (Mult (Const 2) (Mult Var Var)))) x"

text "find power of x / place in polynomial"
fun hel :: "exp \<Rightarrow> nat" where
"hel Var = 1" |
"hel (Const m) = 0" |
"hel (Add t1 t2) = 0" |
"hel (Mult t1 t2)  = (hel t1) + (hel t2)"

value "hel (Mult (Const 1) Var)"
value "hel (Mult Var Var)"
value "hel (Add (Const 3) (Add (Mult (Const 1) Var) (Mult (Const 2) (Mult Var Var))))"

text "you can go through the expression, and add 0 for each Const, 1 for each Var, 2 for each Var*Var,... to a list"
text "and then take that list and convert it to another list"
text " 3 functions needed: add_to_l xs occ num that adds a num to a list xs occ times"
text "then a function count_occ_num xs num that counts the occurrences of a number in a list"
text " and a function that puts it all together, i.e. goes through the expression, creates the occ list and then converts that to the return val" 

fun add_occs :: "nat \<Rightarrow> int \<Rightarrow> int list" where
"add_occs 0 _ = []" |
"add_occs n m = m # (add_occs (n-1) m)"

fun s_add :: "exp \<Rightarrow> exp \<Rightarrow> exp" where
"s_add (Const m) (Const n) = Const (m + n)"|
"s_add Var Var = Mult (Const 2) Var" |
"s_add (Mult (Const m) Var) Var = Mult (Const (m+1)) Var" |
"s_add x y = (if x = y then (Mult (Const 2) x) else (Add x y))"

value "s_add (Mult (Const 2) Var) (Mult (Const 2) Var)"


fun var_occs :: "exp \<Rightarrow> (int \<times> int) list" where
"var_occs (Const m) = [(0, m)]" |
"var_occs Var = [(1,1)]" |
"var_occs (Add e1 e2) = (var_occs e1) @ (var_occs e2)" |
"var_occs (Mult e1 e2) = (var_occs e1) @ (var_occs e2)"

value "var_occs (Const 2)"
value "var_occs (Add (Const 3) (Add (Mult (Const 1) Var) (Mult (Const 2) (Mult Var Var))))"

fun coeffs :: "exp \<Rightarrow> int list" where
"coeffs e = undefined"
(* your definition/proof here *)

value "coeffs (Add (Const 3) (Add (Mult (Const 1) Var) (Mult (Const 2) (Mult Var Var))))"
value "coeffs Var"

text\<open>
Prove that @{text coeffs} preserves the value of the expression:
\<close>

theorem evalp_coeffs: "evalp (coeffs e) x = eval e x"
 apply(induction x arbitrary: e)
  apply(simp_all add: algebra_simps)
  done

(* your definition/proof here *)

text\<open>
Hint: consider the hint in Exercise~\ref{exe:tree0}.
\endexercise
\<close>

end

