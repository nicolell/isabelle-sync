theory Chapter5
imports Main
begin

inductive star :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool"  for r where
refl:  "star r x x" |
step:  "r x y \<Longrightarrow> star r y z \<Longrightarrow> star r x z"

inductive iter :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" for r where
iter_0: "iter r 0 x x" |
iter_Suc: "r x y \<Longrightarrow> iter r n y z \<Longrightarrow> iter r (Suc n) x z"

text\<open>
\section*{Chapter 5}

\exercise
Give a readable, structured proof of the following lemma:
\<close>
lemma assumes T: "\<forall>x y. T x y \<or> T y x"
  and A: "\<forall>x y. A x y \<and> A y x \<longrightarrow> x = y"
  and TA: "\<forall>x y. T x y \<longrightarrow> A x y" 
  and "A x y"
shows "T x y"
proof -
  from T have "T x y \<or> T y x" by simp
  then show "T x y"
  proof 
    assume "T x y" then show ?thesis by simp
  next
    assume "T y x"
    with TA have "A y x" by simp
    with assms(4) have "A x y \<and> A y x" by simp 
    with A have " x = y" by blast
    with T show "T x y" by blast
  qed
qed
(* your definition/proof here *)

text\<open>
Each step should use at most one of the assumptions @{text T}, @{text A}
or @{text TA}.
\endexercise

\exercise
Give a readable, structured proof of the following lemma:
\<close>
value "length [(1::int),2]"
value "3 div (2::int)"
value "drop 2  [(1::int),2,3]"

lemma take_len [simp] : "length xs \<ge> n \<Longrightarrow> length (take n xs) = n" by simp

lemma "(\<exists>ys zs. xs = ys @ zs \<and> length ys = length zs)
      \<or> (\<exists>ys zs. xs = ys @ zs \<and> length ys = length zs + 1)"
proof -
  define n where "n = (length xs + 1) div 2"
  let ?ys = "take n xs"
  let ?zs = "drop n xs"
  have "xs = ?ys @ ?zs" by (simp add: take_drop)
  moreover have "length ?ys = n" by (simp add: n_def)
  moreover have "length ?zs = length xs - n" by simp
  ultimately show ?thesis
  proof (cases "length xs mod 2 = 0")
    case True
    then have "length xs = 2 * n" using n_def by fastforce
    then show ?thesis by (metis \<open>length (take n xs) = n\<close> add_diff_cancel_left' append_take_drop_id length_drop mult_2)
  next
    case False
    then have "length xs = 2 * n - 1" using n_def by (metis Suc_eq_plus1 diff_Suc_1 even_two_times_div_two odd_even_add odd_one
    parity_cases)
    then show ?thesis by (metis False \<open>length (drop n xs) = length xs - n\<close> \<open>length (take n xs) = n\<close>
    \<open>xs = take n xs @ drop n xs\<close> add_diff_cancel_right' diff_right_commute dvd_imp_mod_0 mult_2
    n_def odd_succ_div_two)
  qed
qed


(* your definition/proof here *)

text\<open>
Hint: There are predefined functions @{const take} and {const drop} of type
@{typ "nat \<Rightarrow> 'a list \<Rightarrow> 'a list"} such that @{text"take k [x\<^sub>1,\<dots>] = [x\<^sub>1,\<dots>,x\<^sub>k]"}
and @{text"drop k [x\<^sub>1,\<dots>] = [x\<^bsub>k+1\<^esub>,\<dots>]"}. Let sledgehammer find and apply
the relevant @{const take} and @{const drop} lemmas for you.
\endexercise

\exercise
Give a structured proof by rule inversion:
\<close>
inductive ev :: "nat \<Rightarrow> bool" where
ev0: "ev 0" |
evSS: "ev n \<Longrightarrow> ev(Suc(Suc n))"


text "this is the example from the book"
lemma "ev  n \<Longrightarrow> ev (n - 2)"
proof -
assume "ev n"
from this show "ev (n - 2)"
proof cases
case ev0 thus "ev (n - 2)" by (simp add: ev.ev0)
next
case (evSS k) thus "ev (n - 2)" by (simp add: ev.evSS)
qed
qed


lemma assumes a: "ev(Suc(Suc n))" shows "ev n"
proof -
  from a show "ev n"
  proof cases
    case ev0
    then show "ev n"  using assms ev.simps by blast
  next
    case evSS
    then have "ev n" by simp
  qed
qed


(* your definition/proof here *)

text\<open>
\exercise
Give a structured proof by rule inversions:
\<close>

lemma "\<not> ev(Suc(Suc(Suc 0)))"
proof 
  assume "ev (Suc(Suc(Suc 0)))"
  then have "ev (Suc 0)" by cases
  thus False by cases
qed
(* your definition/proof here *)

text\<open>
If there are no cases to be proved you can close
a proof immediateley with \isacom{qed}.
\endexercise

\exercise
Recall predicate @{const star} from Section 4.5 and @{const iter}
from Exercise~\ref{exe:iter}.
\<close>

lemma "iter r n x y \<Longrightarrow> star r x y"
proof (induction rule: iter.induct)
  case (iter_0 x)
  then show ?case by (simp add: star.refl)
next
  case (iter_Suc x y n z)
  then show ?case by (simp add: star.step)
qed

(* your definition/proof here *)

text\<open>
Prove this lemma in a structured style, do not just sledgehammer each case of the
required induction.
\endexercise

\exercise
Define a recursive function
\<close>

fun elems :: "'a list \<Rightarrow> 'a set" where
"elems [] =  {}" |
"elems (x # xs) = {x} \<union> elems xs"
(* your definition/proof here *)

text\<open> that collects all elements of a list into a set. Prove \<close>

lemma "x \<in> elems xs \<Longrightarrow> \<exists>ys zs. xs = ys @ x # zs \<and> x \<notin> elems ys" (is "?L \<Longrightarrow> ?R")
proof (induction xs)
  case Nil
  then show ?case by simp
next
  case (Cons a xs)
  show ?case
  proof (cases "x = a")
    case True
    then show ?thesis using Cons.prems by fastforce
  next
    case False
    then have "x \<in> elems xs" using Cons.prems by simp
    then obtain ys zs where "xs = ys @ x # zs" "x \<notin> elems ys" using Cons.IH by blast
    then show ?thesis by auto
  qed
qed



(* your definition/proof here *)

text\<open>
\endexercise

\exercise
Extend Exercise~\ref{exe:cfg} with a function that checks if some
\mbox{@{text "alpha list"}} is a balanced
string of parentheses. More precisely, define a recursive function \<close>
(* your definition/proof here *)
fun balanced :: "nat \<Rightarrow> alpha list \<Rightarrow> bool" where
(* your definition/proof here *)

text\<open> such that @{term"balanced n w"}
is true iff (informally) @{text"a\<^sup>n @ w \<in> S"}. Formally, prove \<close>

corollary "balanced n w \<longleftrightarrow> S (replicate n a @ w)"


text\<open> where @{const replicate} @{text"::"} @{typ"nat \<Rightarrow> 'a \<Rightarrow> 'a list"} is predefined
and @{term"replicate n x"} yields the list @{text"[x, \<dots>, x]"} of length @{text n}.
\<close>

end

